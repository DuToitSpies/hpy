import sys
import os.path
from setuptools import setup, Extension
from setuptools.command.build_clib import build_clib
import sysconfig
import platform

# this package is supposed to be installed ONLY on CPython. Try to bail out
# with a meaningful error message in other cases.
if sys.implementation.name != 'cpython':
    msg = 'ERROR: Cannot install and/or update hpy on this python implementation:\n'
    msg += f'    sys.implementation.name == {sys.implementation.name!r}\n\n'
    if '_hpy_universal' in sys.builtin_module_names:
        # this is a python which comes with its own hpy implementation
        import _hpy_universal
        if hasattr(_hpy_universal, 'get_version'):
            hpy_version, git_rev = _hpy_universal.get_version()
            msg += f'This python implementation comes with its own version of hpy=={hpy_version}\n'
            msg += '\n'
            msg += 'If you are trying to install hpy through pip, consider to put the\n'
            msg += 'following in your requirements.txt, to make sure that pip will NOT\n'
            msg += 'try to re-install it:\n'
            msg += f'    hpy=={hpy_version}'
        else:
            msg += 'This python implementation comes with its own version of hpy,\n'
            msg += 'but the exact version could not be determined.\n'
        #
    else:
        # this seems to be a python which does not support hpy
        msg += 'This python implementation does not seem to support hpy:\n'
        msg += '(built-in module _hpy_universal not found).\n'
        msg += 'Please contact your vendor for more informations.'
    sys.exit(msg)


this_directory = os.path.abspath(os.path.dirname(__file__))
with open(os.path.join(this_directory, 'README.md'), encoding='utf-8') as f:
    LONG_DESCRIPTION = f.read()

if 'HPY_DEBUG_BUILD' in os.environ:
    # -fkeep-inline-functions is needed to make sure that the stubs for HPy_*
    # functions are available to call inside GDB
    EXTRA_COMPILE_ARGS = [
        '-g', '-O0', '-UNDEBUG',
        '-fkeep-inline-functions',
        #
        ## these flags are useful but don't work on all
        ## platforms/compilers. Uncomment temporarily if you need them.
        #'-Wfatal-errors',    # stop after one error (unrelated to warnings)
        #'-Werror',           # turn warnings into errors
    ]
else:
    EXTRA_COMPILE_ARGS = []

if '_HPY_DEBUG_FORCE_DEFAULT_MEM_PROTECT' not in os.environ:
    EXTRA_COMPILE_ARGS += ['-D_HPY_DEBUG_MEM_PROTECT_USEMMAP']

if platform.system() == "Windows":
    EXTRA_COMPILE_ARGS += ['/WX']
else:
    EXTRA_COMPILE_ARGS += ['-Werror']


def get_scm_config():
    """
    We use this function as a hook to generate version.h before building.
    """
    import textwrap
    import subprocess
    import pathlib
    import setuptools_scm

    version = setuptools_scm.get_version()
    try:
        gitrev = subprocess.check_output('git rev-parse --short HEAD'.split(),
                                         encoding='utf-8')
        gitrev = gitrev.strip()
    except subprocess.CalledProcessError:
        gitrev = "__UNKNOWN__"

    version_h = pathlib.Path('.').joinpath('hpy', 'devel', 'include', 'hpy', 'version.h')
    version_h.write_text(textwrap.dedent(f"""
        // automatically generated by setup.py:get_scm_config()
        #define HPY_VERSION "{version}"
        #define HPY_GIT_REVISION "{gitrev}"
    """))

    version_py = pathlib.Path('.').joinpath('hpy', 'devel', 'version.py')
    version_py.write_text(textwrap.dedent(f"""
        # automatically generated by setup.py:get_scm_config()
        __version__ = "{version}"
        __git_revision__ = "{gitrev}"
    """))

    return {}  # use the default config

HPY_EXTRA_SOURCES = [
    'hpy/devel/src/runtime/argparse.c',
    'hpy/devel/src/runtime/buildvalue.c',
    'hpy/devel/src/runtime/helpers.c',
]

HPY_CTX_SOURCES = [
    'hpy/devel/src/runtime/ctx_bytes.c',
    'hpy/devel/src/runtime/ctx_call.c',
    'hpy/devel/src/runtime/ctx_capsule.c',
    'hpy/devel/src/runtime/ctx_err.c',
    'hpy/devel/src/runtime/ctx_module.c',
    'hpy/devel/src/runtime/ctx_object.c',
    'hpy/devel/src/runtime/ctx_type.c',
    'hpy/devel/src/runtime/ctx_tracker.c',
    'hpy/devel/src/runtime/ctx_listbuilder.c',
    'hpy/devel/src/runtime/ctx_tuple.c',
    'hpy/devel/src/runtime/ctx_tuplebuilder.c',
]

HPY_INCLUDE_DIRS = [
    'hpy/devel/include',
    'hpy/universal/src',
    'hpy/debug/src/include',
    'hpy/trace/src/include',
]

HPY_EXTRA_LIB_NAME = "hpyextra"
HPY_CTX_LIB_NAME = "hpyctx"


def get_hpy_runtime_includes():
    """ Computes a list of include directories for building the static
        libraries. This only uses module 'sysconfig'.
    """
    default_include = sysconfig.get_path("include")
    plat_include = sysconfig.get_path("platinclude")
    config_h_dir = os.path.dirname(sysconfig.get_config_h_filename())
    include_dirs = [default_include]
    if default_include != plat_include:
        include_dirs.append(plat_include)
    if config_h_dir not in (default_include, plat_include):
        include_dirs.append(config_h_dir)
    return include_dirs + HPY_INCLUDE_DIRS


class build_clib_hpy(build_clib):
    """ Special build_clib command for building HPy's static libraries defined
        by 'STATIC_LIBS' below. The behavior differs in following points:
        (1) Option 'force' is set such that static libs will always be renewed.
        (2) Method 'get_library_names' always returns 'None'. This is because
            we only use this command to build static libraries for shipping
            them. We don't need them for linking here.
        (3) This command consumes a custom build info key 'abi' that is used
            to create a separate build temp directories for each ABI and an
            ABI-specific output directory. This is necessary to avoid incorrect
            sharing of (temporary) build artifacts.
        (4) The resulting static library is written to build_ext's output
            directory. Currently, we use hard-coded sub-directory 'hpy/devel'.
    """
    def finalize_options(self):
        super().finalize_options()
        self.force = 1

    def get_library_names(self):
        # We only build static libraries for shipping. We don't want that our
        # extensions (i.e. 'hpy.universal' etc) link to these libs.
        return None

    def build_libraries(self, libraries):
        build = self.get_finalized_command('build')
        # we just inherit the 'inplace' option from 'build_ext'
        inplace = self.get_finalized_command('build_ext').inplace
        if inplace:
            # the inplace option requires to find the package directory
            # using the build_py command for that
            build_py = self.get_finalized_command('build_py')
            lib_dir = os.path.abspath(build_py.get_package_dir('hpy.devel'))
        else:
            lib_dir = os.path.join(build.build_lib, 'hpy', 'devel')

        for lib in libraries:
            lib_name, build_info = lib
            abi = build_info.get('abi')
            # Call super's build_libraries with just one library in the list
            # such that we can temporarily change the 'build_temp'.
            orig_build_temp = self.build_temp
            orig_build_clib = self.build_clib
            self.build_temp = os.path.join(orig_build_temp, 'lib', abi)
            self.build_clib = os.path.join(lib_dir, 'lib', abi)
            try:
                super().build_libraries([lib])
            finally:
                self.build_temp = orig_build_temp
                self.build_clib = orig_build_clib


STATIC_LIBS = [(HPY_EXTRA_LIB_NAME,
                {'sources': HPY_EXTRA_SOURCES,
                 'include_dirs': get_hpy_runtime_includes(),
                 'abi': 'universal',
                 'macros': [('HPY_ABI_HYBRID', None)]}),
               (HPY_CTX_LIB_NAME,
                {'sources': HPY_EXTRA_SOURCES + HPY_CTX_SOURCES,
                 'include_dirs': get_hpy_runtime_includes(),
                 'abi': 'cpython',
                 'macros': [('HPY_ABI_CPYTHON', None)]})]

EXT_MODULES = [
    Extension('hpy.universal',
              ['hpy/universal/src/hpymodule.c',
               'hpy/universal/src/ctx.c',
               'hpy/universal/src/ctx_meth.c',
               'hpy/universal/src/ctx_misc.c',
               'hpy/debug/src/debug_ctx.c',
               'hpy/debug/src/debug_ctx_cpython.c',
               'hpy/debug/src/debug_handles.c',
               'hpy/debug/src/dhqueue.c',
               'hpy/debug/src/memprotect.c',
               'hpy/debug/src/stacktrace.c',
               'hpy/debug/src/_debugmod.c',
               'hpy/debug/src/autogen_debug_wrappers.c',
               'hpy/trace/src/trace_ctx.c',
               'hpy/trace/src/_tracemod.c',
               'hpy/trace/src/autogen_trace_wrappers.c',
               'hpy/trace/src/autogen_trace_func_table.c']
              + HPY_EXTRA_SOURCES
              + HPY_CTX_SOURCES,
              include_dirs=HPY_INCLUDE_DIRS,
              extra_compile_args=[
                  # so we need to enable the HYBRID ABI in order to implement
                  # the legacy features
                  '-DHPY_ABI_HYBRID',
                  '-DHPY_DEBUG_ENABLE_UHPY_SANITY_CHECK',
                  '-DHPY_EMBEDDED_MODULES',
              ] + EXTRA_COMPILE_ARGS
              )
    ]

DEV_REQUIREMENTS = [
    "pytest",
    "pytest-xdist",
    "filelock",
]

setup(
    name="hpy",
    author='The HPy team',
    author_email='hpy-dev@python.org',
    url='https://hpyproject.org',
    license='MIT',
    description='A better C API for Python',
    long_description=LONG_DESCRIPTION,
    long_description_content_type='text/markdown',
    packages=['hpy.devel', 'hpy.debug', 'hpy.trace'],
    include_package_data=True,
    extras_require={
        "dev": DEV_REQUIREMENTS,
    },
    libraries=STATIC_LIBS,
    ext_modules=EXT_MODULES,
    entry_points={
        "distutils.setup_keywords": [
            "hpy_ext_modules = hpy.devel:handle_hpy_ext_modules",
        ],
    },
    cmdclass={"build_clib": build_clib_hpy},
    use_scm_version=get_scm_config,
    setup_requires=['setuptools_scm'],
    install_requires=['setuptools>=64.0'],
    python_requires='>=3.7',
)
