"""
Parse public_api.h and generates various stubs around
"""
import attr
import re
import py
from copy import deepcopy
import pycparser
from pycparser import c_ast
from pycparser.c_generator import CGenerator

DISCLAIMER = """
/*
   DO NOT EDIT THIS FILE!

   This file is automatically generated by tools/autogen.py from tools/public_api.h.
   Run this to regenerate:
       make autogen

*/
"""

def toC(node):
    return toC.gen.visit(node)
toC.gen = CGenerator()


@attr.s
class Function:
    _CTX_NAME = re.compile(r'^_?HPy_?')

    name = attr.ib()
    node = attr.ib(repr=False)

    def _find_typedecl(self, node):
        while not isinstance(node, c_ast.TypeDecl):
            node = node.type
        return node

    def ctx_name(self):
        return self._CTX_NAME.sub(r'ctx_', self.name)

    def is_varargs(self):
        return (len(self.node.type.args.params) > 0 and
                isinstance(self.node.type.args.params[-1], c_ast.EllipsisParam))

    def ctx_decl(self):
        # turn the function declaration into a function POINTER declaration
        newnode = deepcopy(self.node)
        newnode.type = c_ast.PtrDecl(type=newnode.type, quals=[])
        # fix the name of the function pointer
        typedecl = self._find_typedecl(newnode)
        # replace an ellipsis with a 'va_list _vl' argument
        if self.is_varargs():
            arg = c_ast.Decl('_vl', [], [], [],
                c_ast.TypeDecl('_vl', [],
                    c_ast.IdentifierType(['va_list'])),
                None, None)
            newnode.type.type.args.params[-1] = arg
        #
        typedecl.declname = self.ctx_name()
        return toC(newnode)

    def trampoline_def(self):
        rettype = toC(self.node.type.type)
        parts = []
        w = parts.append
        w('static inline')
        w(toC(self.node))
        w('{\n    ')

        if not self.is_varargs():
            if rettype == 'void':
                w('ctx->%s' % self.ctx_name())
            else:
                w('return ctx->%s' % self.ctx_name())
            w('(')
            params = [p.name for p in self.node.type.args.params]
            w(', '.join(params))
            w(');')
        else:
            last_param = self.node.type.args.params[-2].name
            w('va_list _vl;')
            w('va_start(_vl, %s);' % last_param)
            if rettype == 'void':
                w('ctx->%s' % self.ctx_name())
            else:
                w('%s _res = ctx->%s' % (rettype, self.ctx_name()))
            w('(')
            params = [p.name for p in self.node.type.args.params[:-1]]
            params.append('_vl')
            w(', '.join(params))
            w(');')
            w('va_end(_vl);')
            if rettype != 'void':
                w('return _res;')

        w('\n}')
        return ' '.join(parts)


class FuncDeclVisitor(pycparser.c_ast.NodeVisitor):
    def __init__(self):
        self.functions = []

    def visit_Decl(self, node):
        if not isinstance(node.type, c_ast.FuncDecl):
            return
        name = node.name
        if not name.startswith('HPy') and not name.startswith('_HPy'):
            print('WARNING: Ignoring non-hpy declaration: %s' % name)
            return
        self.functions.append(Function(name, node))


class AutoGen:

    def __init__(self, filename):
        self.ast = pycparser.parse_file(filename, use_cpp=True)
        #self.ast.show()
        self.collect_functions()

    def collect_functions(self):
        v = FuncDeclVisitor()
        v.visit(self.ast)
        self.functions = v.functions

    def gen_ctx_decl(self):
        lines = []
        w = lines.append
        w('struct _HPyContext_s {')
        w('    int ctx_version;')
        for f in self.functions:
            w('    %s;' % f.ctx_decl())
        w('};')
        return '\n'.join(lines)

    def gen_ctx_def(self):
        lines = []
        w = lines.append
        w('struct _HPyContext_s global_ctx = {')
        w('    .ctx_version = 1,')
        for f in self.functions:
            name = f.ctx_name()
            w('    .%s = &%s,' % (name, name))
        w('};')
        return '\n'.join(lines)

    def gen_func_trampolines(self):
        lines = []
        for f in self.functions:
            lines.append(f.trampoline_def())
            lines.append('')
        return '\n'.join(lines)


def main():
    root = py.path.local(__file__).dirpath().dirpath()
    universal_headers = root.join('hpy-api', 'hpy_devel', 'include', 'universal')
    autogen_ctx = universal_headers.join('autogen_ctx.h')
    autogen_func = universal_headers.join('autogen_func.h')
    autogen_ctx_def = root.join('cpython-universal', 'src', 'autogen_ctx_def.h')

    autogen = AutoGen(root.join('tools', 'public_api.h'))
    for func in autogen.functions:
        print(func)

    ctx_decl = autogen.gen_ctx_decl()
    func_trampolines = autogen.gen_func_trampolines()
    ctx_def = autogen.gen_ctx_def()

    with autogen_ctx.open('w') as f:
        print(DISCLAIMER, file=f)
        print(ctx_decl, file=f)

    with autogen_func.open('w') as f:
        print(DISCLAIMER, file=f)
        print(func_trampolines, file=f)

    with autogen_ctx_def.open('w') as f:
        print(DISCLAIMER, file=f)
        print(ctx_def, file=f)

if __name__ == '__main__':
    main()
